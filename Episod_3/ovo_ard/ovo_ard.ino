/*
  Измерение температуры, влажности на уровне лотка (BME280 - нулевой)
  Измерение температуры вблизи внутреннего тена (DS18B20 - первый)
  Измерение наружной температуры в помещении (DS18B20 - второй) 
  Измерение атмосферного давления (BME280 - опция)

  PID регулятор температуры: На основе показаний датчиков температуры
                             {нулевой - основной, первый - вспомогательный}

                             Регулирует подвод тепла увеличивая или уменьшая ток тена
                             В качестве тена могут быть лампы накаливания
                             Регулировка посредством ШИМ (источник тока - аккумулятор 12в)

  На плате есть датчик освещенности, кот. используется для регулировки светодиодных лент

  RTC таймер DS с батарейкой можно использовать для настройки режимов работы всей установки
  на весь технологический цикл (основной алгоритм установки)

  Включать-выключать вентилятор, свет, нагрев и прочие узлы можно посредством блока реле                                                        
*/
//--- RTC library DS1307 --------------------------------------------------------------------------- 
#include <DS1307.h>
DS1307 rtc(SDA, SCL);

//--- Gyver библиотека таймеров --------------------------------------------------------------------
/* Как использовать
void setMicros(bool mode);      // включить микросекундный режим (true)
void setTimerMode();            // установить в режим таймера (остановится после срабатывания)
void setPeriodMode();        // установить в режим периода (перезапустится после срабатывания)
void setTime(uint32_t prd);     // установить время
void attach(void (*handler)()); // подключить коллбэк
void detach();                  // отключить коллбэк
void start();                   // запустить/перезапустить таймер
void resume();                  // продолжить после остановки
void stop();                    // остановить/приостановить таймер
void force();                   // принудительно переполнить таймер

// в режиме периода однократно вернёт true при каждом периоде
// в режиме таймера будет возвращать true при срабатывании
bool tick();

bool ready();           // однократно вернёт true при срабатывании (флаг)
bool elapsed();         // всегда возвращает true при срабатывании
bool active();          // работает ли таймер (start/resume)
bool status();          // elapsed+active: работает ли таймер + не сработал ли он

uint32_t timeLeft();    // остаток времени в мс
uint8_t timeLeft8();    // остаток времени в 0-255
uint16_t timeLeft16();  // остаток времени в 0-65535  
 */
//--------------------------------------------------------------------------------------------------
#include <TimerMs.h>
// (период, мс), (0 не запущен / 1 запущен), (режим: 0 период / 1 таймер)
TimerMs tmr(1000, 0, 0);   //--- DS опрашивать 1 раз в секунду
TimerMs tmr2(2000, 0, 0);  //--- BME280 - 1 раз в 2 секунды
TimerMs tmr3(5000, 0, 0);  //--- Photosensor 1 раз в 5 секунд
TimerMs tmr4(5000, 0, 0);  //--- RTC опрос 1 раз в 5 секунд

TimerMs tmrOut(5000, 0, 0);//--- Для вывода

//--- Вместо Serial -------------------------------------------------------------------------------- 
//#define MU_STREAM     // подключить Stream.h (readString, readBytes...)
#define MU_PRINT      // подключить Print.h (print, println)
//#define MU_TX_BUF 64  // буфер отправки. По умолч. 8. Можно отключить (0)
//#define MU_RX_BUF 64  // буфер приёма. По умолч. 8. Можно отключить (0)
#include <MicroUART.h>
MicroUART uart;

//---   Для работы с датчиком DS18B20  -------------------------------------------------------------
#include <microDS18B20.h>
#define DS_SENSOR_AMOUNT  2
uint8_t addr[][8]= {{0x28, 0xEE, 0x1A, 0x1B, 0x2F, 0x16, 0x2, 0x78},  //--- на шилде
                    {0x28, 0xEE, 0xAE, 0x47, 0x30, 0x16, 0x1, 0x15},  //--- второй канал
                   }; 
// указываем DS_ADDR_MODE для подключения блока адресации
// и создаём массив датчиков на пине DS_PIN
#define DS_PIN  8  
MicroDS18B20<DS_PIN, DS_ADDR_MODE> ds[DS_SENSOR_AMOUNT];
#include <DS_raw.h>
#include <microOneWire.h>

//--------------------------------------------------------------------------------------------------
//   Пример индивидуальных настроек датчика под ваше применение
//   См. константы в GyverBME280.h , стандартные настройки можно изменить там же в классе GyverMBE280
//   Настройки вступают в силу только ПОСЛЕ .begin();
//--------------------------------------------------------------------------------------------------
#include <GyverBME280.h>                            // Подключение библиотеки
GyverBME280 bme;                                    // Создание обьекта bme

//--------------------------------------------------------------------------------------------------
//   Фоторезистор
//--------------------------------------------------------------------------------------------------
#define PIN_PHOTORESISTOR A3

//==================================================================================================
typedef struct {
  char* dwk;
  char* dat;
  char* tim;  
}stDATETIME_t;
stDATETIME_t datetime;

typedef struct {
  float t;
  float h;
  float p;  
}stBME280_t;
stBME280_t clim;

float ds_t[DS_SENSOR_AMOUNT];

uint16_t photo_sens;  

//==================================================================================================


  
void setup() {
  
  //--- Запуск последовательного порта  
  uart.begin(9600);
  pinMode(13, 1);

  //--- настраиваем режимы BME280
  bme.setFilter(FILTER_COEF_8);                     // Настраиваем коофициент фильтрации
  bme.setTempOversampling(OVERSAMPLING_8);          // Настраиваем передискретизацию для датчика температуры
  bme.setPressOversampling(OVERSAMPLING_16);        // Настраиваем передискретизацию для датчика давления
  bme.setStandbyTime(STANDBY_250MS);                // Устанавливаем время сна между измерениями (у нас обычный циклический режим)
  bme.begin();                                      // Если на этом настройки окончены - инициализируем датчик

  //--- устанавливаем адреса на датчики DS18B20
  for (int i = 0; i < DS_SENSOR_AMOUNT; i++) {
    ds[i].setAddress(addr[i]);
  }  

  // Initialize the rtc object
  rtc.begin();  
  // Set the clock to run-mode
  rtc.halt(false);  
  // The following lines can be uncommented to set the time
  //rtc.setDOW(FRIDAY);        // Set Day-of-Week to SUNDAY
  //rtc.setTime(21, 59, 0);     // Set the time to 12:00:00 (24hr format)
  //rtc.setDate(20, 8, 2023);   // Set the date to October 3th, 2010  

  //--- таймеры в режиме периодического срабатывания
  tmr.setPeriodMode();                              // для DS
  tmr.start();

  tmr2.setPeriodMode();                             // Для BME280
  tmr2.start();

  tmr3.setPeriodMode();                             // Для Photosensor
  tmr3.start(); 

  tmr4.setPeriodMode();                             // Для снятия показаний RTC
  tmr4.start();   

  tmrOut.setPeriodMode();                           // Для вывода
  tmrOut.start();
}

//===================================================================================================

void loop() {
  
  //--- Работа на прием из uart -------------------------------------------
  while (uart.available()) uart.write(uart.read());
  //-----------------------------------------------------------------------

  //--- Опрос датчика BME280 ----------------------------------------------
  Work_BME280();
  //-----------------------------------------------------------------------

  //--- Получение результата преобразования от датчиков DS18B20 -----------  
  Work_DS18B20();
  //-----------------------------------------------------------------------

  //--- Получение результата фотосенсора ----------------------------------  
  Work_Photosensor();
  //-----------------------------------------------------------------------  

  //--- Получение данных из RTC -------------------------------------------  
  Work_RTC();
  //-----------------------------------------------------------------------  

  //--- Вывод всех данных -------------------------------------------------
  Out_All();
  //-----------------------------------------------------------------------
}

//------------------------------------------------------------------------

void Work_RTC() {
  if (tmr4.tick()) {    
    // День недели
    datetime.dwk = rtc.getDOWStr();
 
    // Дата
    datetime.dat = rtc.getDateStr();

    // Время
    datetime.tim = rtc.getTimeStr(); 
  }
}

void Work_BME280() {
  if (tmr2.tick()) {    
    // получаем данные из BME280
    clim.t = bme.readTemperature();
    clim.h = bme.readHumidity();
    clim.p = pressureToMmHg(bme.readPressure());
  }
} 

void Out_All() {

  // Выводим данные из BME280
  if (tmrOut.tick()) {

      uart.println("---------------------------------------------");    
      // День недели
      uart.print(datetime.dwk);
      uart.print(" ");  
      // Дата
      uart.print(datetime.dat);
      uart.print(" -- ");
      // Время
      uart.println(datetime.tim);
      uart.println("---------------------------------------------"); 
    
      uart.print("BME280.t:  ");
      uart.print(clim.t);             // Выводим темперутуру в [*C]
      uart.println(" *C");

      uart.print("BME280.h:  ");  
      uart.print(clim.h);             // Выводим влажность в [%]
      uart.println(" %");

      uart.print("BME280.p:  ");
      uart.print(clim.p);             // Выводим давление в мм рт. столба
      uart.println(" mm Hg");
      uart.println("");    


      // выводим показания ds
      for (int i = 0; i < DS_SENSOR_AMOUNT; i++) {
        uart.print("ds_t[");
        uart.print(i+1);
        uart.print("]:\t");
        uart.println(ds_t[i]);
      }
      uart.println(); 

      // выводим показание фотосенсора
      uart.print("Light: ");
      uart.println(photo_sens); 
      uart.println(); 
  }  
}

 void Work_DS18B20() {
  if (tmr.tick()) {
    
    // получаем данные из ds массива датчиков
    for (int i = 0; i < DS_SENSOR_AMOUNT; i++) {
      ds_t[i] = ds[i].getTemp();
    }

    // запрашиваем новые данные
    for (int i = 0; i < DS_SENSOR_AMOUNT; i++) {
      ds[i].requestTemp();
    }
  }
}

void Work_Photosensor() {
  if (tmr3.tick()) {
    photo_sens = analogRead(PIN_PHOTORESISTOR);
  }
}

// вызывается в прерывании при приёме байта
void MU_serialEvent() {
  static bool val = 0;
  digitalWrite(13, val = !val);
  //uart.write(uart.read());
}

float k = 0.1;  // коэффициент фильтрации, 0.0-1.0
// бегущее среднее
float expRunningAverage(float newVal) {
  static float filVal = 0;
  filVal += (newVal - filVal) * k;
  return filVal;
}
