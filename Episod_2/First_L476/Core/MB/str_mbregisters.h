#ifndef STR_MBREGISTERS_H
#define STR_MBREGISTERS_H

/**
  ******************************************************************************
  * @file           : str_flash.h
  * @brief          : Модуль тестовых регистров для работы MODBUS RTU
  * 				  (стандартные 16 бит) INPUT & HOLDING
  ******************************************************************************
  * @attention
  *
  * Модуль тестовых регистров для работы MODBUS RTU (стандартные 16 бит)
  * INPUT & HOLDING
  * Структуры объединены в союзы с массивами 16-ти битных регистров
  * внутрипрограммное использование - по именам из структур
  * в протоколе MODBUS - по номерам в массиве
  *
  * Реализована функция отслеживания изменений главных настроечных регистров
  * ModifyMainRegisters() - можно расширять для любых других регистров
  * Редактируются все регистры holding, часть настроечных - копируются в input регистры
  * Какие регистры следует зафиксировать - указано в регистре editinfo
  * Изменения возможны только по совпадению технического пароля в регистре pwd
  * Также - запись во флеш производится по наличию условного бита 0x8000 в регистре editinfo
  *
  * Author: ln.starmark@gmail.com
  * Date:  15.02.2020
  */

/*
 * Дополнить MB функцией 17 - Информация о регистрах
 * Inputs:
 * 	const char **InfoRgINP = {"idbaud:bb","timeout:uw","mode:uw","errcnt:uw","val:sw","bigcnt:ud","bigval:sd","speed:f","pi:fd"};
 * Holding:
 * 	const char **InfoRgHLD = {"idbaud:bb",..};
 *
 *
 * typedef enum {bb, uw, sw, ul, sl, f, d, cm } eTypeRg;
 *  bb	2 bytes,
 *  uw	uint16_t,
 *  sw   int16_t,
 *  ul   uint32_t,
 *  sl   int32_t,
 *  f    float,
 *  d    double,
 *  cm   command string (необходим буфер для команд - фикс. длины или для цепочки типа string)
 */

#include "str_helper.h"
#include "str_onoffmodule.h"



extern volatile uint32_t UID[];
extern volatile uint16_t FSZ[];

//--- Секция данных - только чтение -----------------------------------------

// Прошиваются и остаются неизменными (addrbaud может изменяться в его копии)
struct stINP
{
	//--- технический раздел - используется для основных настроек устройства --------------
	// копия настроек из секции HLD - сохраняется во флеш в соответствующей версии прошивки
	uint16_t idbaud;  	// id & baud задаются при прошивке
	uint16_t timeout;	// тормознутость устройства заданная при прошивке
	uint16_t mode;    	// режим работы контроллера
	uint16_t errcnt;    // счетчик ошибок (например - при отладке шины I2C)
    //-------------------------------------------------------------------------------------

	// регистр состояния устройства - используется разработчиками по условиям технологии
	uint16_t status;  	// сообщения о текущем состоянии контроллера

	// неизменяеая информация
	uint16_t serial_0;	// серийный номер - уникальный - берется из контроллера устройства
	uint16_t serial_1;	//
	uint16_t serial_2;	//
	uint16_t serial_3;	//
	uint16_t serial_4;	//
	uint16_t serial_5;	//

	uint16_t flashsize; // Размер памяти программ - берется из контроллера устройства

	// заводские установки - вносятся при прошивке устройства
	uint16_t devtype; 	// тип устройства по реестру предприятия изготовителя
	uint16_t firmware;	// версия ПО устройства на момент прошивки

	// рабочие данные контроллера - поступают с датчиков, после фильтров и предобработки
	uint16_t inp0;
	uint16_t inp1;
	uint16_t inp2;
	uint16_t inp3;
	uint16_t inp4;
	uint16_t inp5;
	uint16_t inp6;
	uint16_t inp7;

	//
	uint16_t P_86BSD;		// давление по чипу 86BSD
	uint16_t conductivity;  // проводимость по ADC uPU
	uint16_t T_fahr;		// температура по чипу BME280
	uint16_t T_chip;		// температура uPU (ADC1_IN17 and ADC3_IN17)
	uint16_t T_cels;		// температура по чипу BME280
	uint16_t T_86BSD;		// температура по чипу 86BSD
	uint16_t reserv1;
	uint16_t reserv2;
};

typedef union INP
{
	struct stINP    st;
	uint16_t 		arr[VOLUME_INPUT];
}uINPUT;


/**
*uint16_t id_baud; // id & baud можно изменять
*uint16_t timeout; // информацию о тормознутости устройства можно изменять
*uint16_t mode;    // режим работы контроллера
*uint16_t reserv0; //
*uint16_t editinfo;// сюда вносятся биты изменений 0b 0000 1111
*   					// после изменения ID, BAUD, TIMEOUT, MODE
*					// менеджер задач закрепляет новые данные в EEPROM, FLASH
*					// также копирует их в секцию INP
*					// и затем - снимает эти биты как выполненную работу
*uint16_t pwd;		// пароль разрешения модификации регистров
*					// id_baud, timeout, mode
*
* алгоритм модификации:
* 1	записать в pwd заветное слово (ZB: 0xAAAA) 	функцией 0x06
* 2  записать в регистры требуемые значения 			функцией 0x16
* 3  записать в регистр editinfo требуемые биты
* ZB: Fn6 -> 0x1234
*     Fn16-> Пачку регистров {id_baud, timeout, mode}, либо 1 функцией Fn6
*     Fn6 -> указать в регистре соответствующие биты	 0b10000111
* менеджер смотрит биты в editinfo и если они есть, то
* смотрит пароль в pwd, и если он правильный, то
* модифицирует регистры, снимает биты в editinfo, пишет в EEPROM, FLASH и
* пишет отчет в шину MODBUS
* затем идет на перезагрузку, чтобы вступили в силу настройки
* если пароль был не правильный, то просто затирает регистры editinfo, pwd
*/



struct stHLD
{
	//--- технический раздел - используется для основных настроек устройства ---------
	uint16_t idbaud;  		// id & baud можно изменять
	uint16_t timeout; 		// информацию о тормознутости устройства можно изменять
	uint16_t mode;    		// режим работы контроллера

	uint16_t editinfo;		// сюда вносятся биты изменений 0b 0000 1111
	uint16_t pwd;			// пароль разрешения модификации регистров
    //--------------------------------------------------------------------------------

	// Сюда заносят с верхнего уровня UID 96 бит и новый ID
	uint16_t ser0;
	uint16_t ser1;
	uint16_t ser2;
	uint16_t ser3;
	uint16_t ser4;
	uint16_t ser5;
    uint16_t newID;

	uint16_t dt0;			// данные для чтения и записи
	uint16_t dt1;
	uint16_t dt2;
	uint16_t dt3;

	uint16_t par0;			// параметры дополнительных настроек
	uint16_t par1;
	uint16_t par2;
	uint16_t par3;

	uint16_t reserv0;		// возможно использование по требованиям технологии
	uint16_t reserv1;
	uint16_t reserv2;
};

typedef union HLD
{
	struct stHLD 	st;
	uint16_t 		arr[VOLUME_HOLDING];
}uHOLD;

extern uINPUT inp;
extern uHOLD  hld;

void InitRegsInp(void);
void InitRegsHld(void);

#ifdef STR_MODIFYREGISTERS
bool ModifyMainRegisters(void);
bool CompareUID(void);
#endif

//--------------------------------------------------------------------------
extern int16_t t__cels;

#endif // STR_MBREGISTERS_H

